Понял. Предлагаю следующую архитектуру:

UI — Qt (QWidget и т.п).
Последовательный порт — отдельный класс с POSIX API и отдельным std::thread.
Передача данных между UI и потоком порта — через потокобезопасные очереди на базе std::mutex + std::condition_variable.
В UI вызываем методы для отправки данных (кладем в очередь), а из потока порта читаем и пишем.
Для передачи принятых данных обратно в UI — можно запускать таймер в UI, который периодически проверяет очередь с принятыми данными и обновляет интерфейс.
Таким образом сигналов и слотов для взаимодействия потоков не используем.
Пример реализации
1. Класс управления последовательным портом (SerialPortManager.h)
cpp

#pragma once

#include <thread>
#include <mutex>
#include <queue>
#include <condition_variable>
#include <vector>
#include <string>

class SerialPortManager {
public:
    SerialPortManager(const std::string& portName);
    ~SerialPortManager();

    bool open();
    void close();
    bool isOpen() const;

    // Добавить данные для отправки
    void sendData(const std::vector<uint8_t>& data);

    // Забрать полученные данные (если есть)
    // Возвращает true если данные были, и кладет в outData
    bool receiveData(std::vector<uint8_t>& outData);

private:
    void threadFunc();

    std::string m_portName;
    int m_fd = -1;

    std::thread m_thread;
    bool m_running = false;

    // Очередь отправки
    std::mutex m_writeMutex;
    std::condition_variable m_writeCv;
    std::queue<std::vector<uint8_t>> m_writeQueue;

    // Очередь приема
    std::mutex m_readMutex;
    std::queue<std::vector<uint8_t>> m_readQueue;
};
2. Реализация SerialPortManager.cpp
cpp

#include "SerialPortManager.h"
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>
#include <iostream>
#include <cstring>
#include <chrono>

SerialPortManager::SerialPortManager(const std::string &portName) : m_portName(portName) {}

SerialPortManager::~SerialPortManager() {
    close();
}

bool SerialPortManager::open() {
    if (m_fd != -1)
        return true; // уже открыт

    m_fd = ::open(m_portName.c_str(), O_RDWR | O_NOCTTY | O_NONBLOCK);
    if (m_fd == -1) {
        perror("open serial port");
        return false;
    }

    // Настройка порта
    struct termios tty;
    if (tcgetattr(m_fd, &tty) != 0) {
        perror("tcgetattr");
        ::close(m_fd);
        m_fd = -1;
        return false;
    }

    cfmakeraw(&tty); // raw mode

    cfsetspeed(&tty, B9600);

    tty.c_cflag |= (CLOCAL | CREAD);
    tty.c_cflag &= ~CSTOPB; // 1 стоп-бит
    tty.c_cflag &= ~PARENB; // no parity
    tty.c_cflag &= ~CSIZE;
    tty.c_cflag |= CS8;     // 8 бит данных
    tty.c_cflag &= ~CRTSCTS; // no hardware flow control

    tty.c_cc[VMIN] = 0;    // read ничем не блокируется, возвращает сколько есть
    tty.c_cc[VTIME] = 10;  // таймаут 1с (в десятых долях секунды)

    if (tcsetattr(m_fd, TCSANOW, &tty) != 0) {
        perror("tcsetattr");
        ::close(m_fd);
        m_fd = -1;
        return false;
    }

    // Запускаем поток
    m_running = true;
    m_thread = std::thread(&SerialPortManager::threadFunc, this);

    return true;
}

void SerialPortManager::close() {
    if (m_fd != -1) {
        m_running = false;
        m_writeCv.notify_all();
        if (m_thread.joinable())
            m_thread.join();

        ::close(m_fd);
        m_fd = -1;
    }
}

bool SerialPortManager::isOpen() const {
    return m_fd != -1;
}

Понял — вы хотите оставить Qt для интерфейса, а работу с портом реализовать на чистом C++ с POSIX API, при этом избегая использования сигналов и слотов для взаимодействия между потоками. Тогда вам потребуется реализовать собственную систему потокобезопасных очередей для обмена данными между потоками.

---

## Общий подход

1. **Поток для порта + отдельный поток для UI** (UI в основном потоке).
2. **Обмен данными** — через потокобезопасные очереди (например, с помощью `std::mutex` и `std::condition_variable`).
3. От UI поток — кладет данные в очередь для отправки.
4. В порту — читается из очереди для отправки, пишется в порт.
5. Из порта — полученные данные помещаются в очередь для UI.
6. В UI периодически (например, через таймер или вызов из главного цикла) читается из очереди и обновляется интерфейс.

---

## Реализация

### 1. Потокобезопасная очередь

```cpp
#include <queue>
#include <mutex>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
public:
    void enqueue(const T& data) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_queue.push(data);
        m_cond.notify_one();
    }

    T dequeue() {
        std::unique_lock<std::mutex> lock(m_mutex);
        m_cond.wait(lock, [this]{ return !m_queue.empty(); });
        T val = m_queue.front();
        m_queue.pop();
        return val;
    }

    bool try_dequeue(T& result) {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_queue.empty()) return false;
        result = m_queue.front();
        m_queue.pop();
        return true;
    }

    bool empty() {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_queue.empty();
    }

private:
    std::queue<T> m_queue;
    std::mutex m_mutex;
    std::condition_variable m_cond;
};
2. Поток для работы с портом (POSIX API)
cpp

#include <termios.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>

class SerialPort {
public:
    SerialPort(const char *device) : m_device(device), m_fd(-1), m_running(false) {}

    bool openPort() {
        m_fd = open(m_device, O_RDWR | O_NOCTTY | O_SYNC);
        if (m_fd < 0) {
            perror("open");
            return false;
        }

        struct termios tty;
        memset(&tty, 0, sizeof tty);
        if (tcgetattr(m_fd, &tty) != 0) {
            perror("tcgetattr");
            close(m_fd);
            return false;
        }

        cfsetospeed(&tty, B9600);
        cfsetispeed(&tty, B9600);

        tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;     // 8-bit chars
        tty.c_iflag &= ~IGNBRK;         // disable break processing
        tty.c_lflag = 0;                // no signaling chars, no echo
        tty.c_oflag = 0;                // no remapping, no delays
        tty.c_cc[VMIN]  = 0;
        tty.c_cc[VTIME] = 10; // 1 second read timeout

        tty.c_iflag &= ~(IXON | IXOFF | IXANY);
        tty.c_cflag |= (CLOCAL | CREAD);
        tty.c_cflag &= ~(PARENB | PARODD);
        tty.c_cflag &= ~CSTOPB;
        tty.c_cflag &= ~CRTSCTS;

        if (tcsetattr(m_fd, TCSANOW, &tty) != 0) {
            perror("tcsetattr");
            close(m_fd);
            return false;
        }
        return true;
    }

    void closePort() {
        if (m_fd >= 0) close(m_fd);
        m_fd = -1;
    }

    int getFd() const { return m_fd; }

    ~SerialPort() { closePort(); }

private:
    const char *m_device;
    int m_fd;
    bool m_running;
};
3. Поток обработки порта (чтение-запись)
cpp

#include <thread>
#include <atomic>

class SerialThread {
public:
    SerialThread(const char *device,
                 ThreadSafeQueue<std::vector<uint8_t>> &outQueue,
                 ThreadSafeQueue<std::vector<uint8_t>> &inQueue)
        : m_port(device), m_outQueue(outQueue), m_inQueue(inQueue), m_stopFlag(false) {}

    void start() {
        if (!m_port.openPort()) return;
        m_thread = std::thread(&SerialThread::process, this);
    }

    void stop() {
        m_stopFlag.store(true);
        if (m_thread.joinable()) m_thread.join();
        m_port.closePort();
    }

private:
    void process() {
        int fd = m_port.getFd();
        uint8_t buffer[256];

        while (!m_stopFlag.load()) {
            fd_set readfds, writefds;
            FD_ZERO(&readfds);
            FD_ZERO(&writefds);
            FD_SET(fd, &readfds);
            FD_SET(fd, &writefds);

            struct timeval timeout;
            timeout.tv_sec = 0;
            timeout.tv_usec = 100000; // 100 ms

            int ret = select(fd + 1, &readfds, &writefds, NULL, &timeout);
            if (ret < 0) {
                perror("select");
                break;
            }

            // Чтение
            if (FD_ISSET(fd, &readfds)) {
                ssize_t n = read(fd, buffer, sizeof(buffer));
                if (n > 0) {
                    std::vector<uint8_t> data(buffer, buffer + n);
                    m_inQueue.enqueue(data);
                }
            }

            // Запись
            std::vector<uint8_t> dataToSend;
            if (m_outQueue.try_dequeue(dataToSend)) {
                ssize_t n = write(fd, dataToSend.data(), dataToSend.size());
                if (n < 0) {
                    perror("write");
                }
            }
        }
    }

    SerialPort m_port;
    std::thread m_thread;
    std::atomic<bool> m_stopFlag;
    ThreadSafeQueue<std::vector<uint8_t>> &m_outQueue;
    ThreadSafeQueue<std::vector<uint8_t>> &m_inQueue;
};
4. В UI — основной поток (без сигналов/слотов)
Создаете два объекта очередей:
outQueue — для отправляемых данных
inQueue — для полученных данных
Запускаете поток SerialThread
Для отправки данных: добавляете в outQueue.
Для обработки входящих данных: вызываете периодический метод, например, через QTimer, который проверяет inQueue.
cpp

// В конструкторе MainWindow
outQueue = new ThreadSafeQueue<std::vector<uint8_t>>();
inQueue = new ThreadSafeQueue<std::vector<uint8_t>>();
serialThread = new SerialThread("/dev/tty.usbserial", *outQueue, *inQueue);
serialThread->start();
5. Периодическая обработка входных данных в UI
cpp

// В таймере или через вызов из главного цикла
void MainWindow::processIncoming() {
    std::vector<uint8_t> data;
    while (inQueue->try_dequeue(data)) {
        // Обновляем UI: вставляем данные в элементы
        QString str = QString::fromStdString(std::string(data.begin(), data.end()));
        ui->textEdit->append(str);
    }
}
Итог
Работа с портом — в отдельном потоке с использованием select() и POSIX API.
Обмен данных — через потокобезопасные очереди (ThreadSafeQueue).
Обновление UI — вызывается в основном потоке, без сигналов и слотов, просто через периодическую проверку очереди.